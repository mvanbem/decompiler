use crate::EncodedInstruction;

const TABLE: &[(u32, &str)] = &[
    //
    // === CMPLI (CMPLWI) ===
    //
    // - all zeros
    (0b001010_000_0_0_00000_0000000000000000, "cmplwi r0, 0"),
    // - unsigned immediate
    (0b001010_000_0_0_00000_1111111111111111, "cmplwi r0, 0xffff"),
    // - register A
    (0b001010_000_0_0_11111_0000000000000000, "cmplwi r31, 0"),
    // - L flag
    (0b001010_000_0_1_00000_0000000000000000, "FAIL"),
    // - reserved bit 9
    (0b001010_000_1_0_00000_0000000000000000, "FAIL"),
    // - condition register field D (elided when zero)
    (0b001010_111_0_0_00000_0000000000000000, "cmplwi cr7, r0, 0"),
    // - all ones
    (
        0b001010_111_0_0_11111_1111111111111111,
        "cmplwi cr7, r31, 0xffff",
    ),
    //
    // === ADDI (LI) ===
    //
    // - all zeros
    (0b001110_00000_00000_0000000000000000, "li r0, 0"),
    // - signed immediate
    (0b001110_00000_00000_1111111111111111, "li r0, -1"),
    // - register A
    (0b001110_00000_11111_0000000000000000, "addi r0, r31, 0"),
    // - register D
    (0b001110_11111_00000_0000000000000000, "li r31, 0"),
    // - all ones
    (0b001110_11111_11111_1111111111111111, "addi r31, r31, -1"),
    //
    // === BCx ===
    //
    // - all zeros
    (0b010000_00000_00000_00000000000000_0_0, "bdnznl 0x08000000"),
    // - link flag
    (
        0b010000_00000_00000_00000000000000_0_1,
        "bdnznll 0x08000000",
    ),
    // - absolute flag
    (
        0b010000_00000_00000_00000000000000_1_0,
        "bdnznla 0x00000000",
    ),
    // - target address
    (0b010000_00000_00000_11111111111111_0_0, "bdnznl 0x07fffffc"),
    // - BI operand, condition
    (0b010000_00000_00011_00000000000000_0_0, "bdnzns 0x08000000"),
    // - BI operand, condition register field
    (
        0b010000_00000_11100_00000000000000_0_0,
        "bdnznl cr7, 0x08000000",
    ),
    // - BO operand
    (0b010000_11111_00000_00000000000000_0_0, "b 0x08000000"),
    // - all ones
    (0b010000_11111_11111_11111111111111_1_1, "bla 0xfffffffc"),
    // - all eight simple conditional branches
    (0b010000_01100_00000_00010000000000_0_0, "blt 0x08001000"),
    (0b010000_01100_00001_00010000000000_0_0, "bgt 0x08001000"),
    (0b010000_01100_00010_00010000000000_0_0, "beq 0x08001000"),
    (0b010000_01100_00011_00010000000000_0_0, "bso 0x08001000"),
    (0b010000_00100_00000_00010000000000_0_0, "bnl 0x08001000"),
    (0b010000_00100_00001_00010000000000_0_0, "bng 0x08001000"),
    (0b010000_00100_00010_00010000000000_0_0, "bne 0x08001000"),
    (0b010000_00100_00011_00010000000000_0_0, "bns 0x08001000"),
    // - use every feature
    (
        0b010000_01000_10110_00010010001101_1_1,
        "bdnzeqla cr5, 0x00001234",
    ),
    //
    // === Bx ===
    //
    // - all zeros
    (0b010010_000000000000000000000000_0_0, "b 0x08000000"),
    // - link flag
    (0b010010_000000000000000000000000_0_1, "bl 0x08000000"),
    // - absolute flag
    (0b010010_000000000000000000000000_1_0, "ba 0x00000000"),
    // - target address
    (0b010010_111111111111111111111111_0_0, "b 0x07fffffc"),
    // - all ones
    (0b010010_111111111111111111111111_1_1, "bla 0xfffffffc"),
    //
    // === BCLRx ===
    //
    // - all zeros
    (0b010011_00000_00000_00000_0000010000_0, "bdnznllr"),
    // - link flag
    (0b010011_00000_00000_00000_0000010000_1, "bdnznllrl"),
    // reserved bits 16..=20
    (0b010011_00000_00000_00001_0000010000_1, "FAIL"),
    (0b010011_00000_00000_00010_0000010000_1, "FAIL"),
    (0b010011_00000_00000_00100_0000010000_1, "FAIL"),
    (0b010011_00000_00000_01000_0000010000_1, "FAIL"),
    (0b010011_00000_00000_10000_0000010000_1, "FAIL"),
    // - BI operand, condition
    (0b010011_00000_00011_00000_0000010000_0, "bdnznslr"),
    // - BI operand, condition register field
    (0b010011_00000_11100_00000_0000010000_0, "bdnznllr cr7"),
    // - BO operand
    (0b010011_11111_00000_00000_0000010000_0, "blr"),
    // - all ones
    (0b010011_11111_11111_00000_0000010000_1, "blrl"),
    // - all eight simple conditional branches
    (0b010011_01100_00000_00000_0000010000_0, "bltlr"),
    (0b010011_01100_00001_00000_0000010000_0, "bgtlr"),
    (0b010011_01100_00010_00000_0000010000_0, "beqlr"),
    (0b010011_01100_00011_00000_0000010000_0, "bsolr"),
    (0b010011_00100_00000_00000_0000010000_0, "bnllr"),
    (0b010011_00100_00001_00000_0000010000_0, "bnglr"),
    (0b010011_00100_00010_00000_0000010000_0, "bnelr"),
    (0b010011_00100_00011_00000_0000010000_0, "bnslr"),
    // - use every feature
    (0b010011_01000_10110_00000_0000010000_1, "bdnzeqlrl cr5"),
    //
    // === MFSPR ===
    // - all variants with r0
    (0b011111_00000_00001_00000_0101010011_0, "mfxer r0"),
    (0b011111_00000_01000_00000_0101010011_0, "mflr r0"),
    (0b011111_00000_01001_00000_0101010011_0, "mfctr r0"),
    // - reserved bit 31
    (0b011111_00000_00001_00000_0101010011_1, "FAIL"),
    // - register D
    (0b011111_11111_00001_00000_0101010011_0, "mfxer r31"),
    // - spr operand, illegal value
    (0b011111_00000_00000_00000_0101010011_0, "FAIL"),
    (0b011111_00000_00001_00001_0101010011_0, "FAIL"),
    //
    // === OR (MR) ===
    //
    // - all zeros
    (0b011111_00000_00000_00000_0110111100_0, "mr r0, r0"),
    // - record bit
    (0b011111_00000_00000_00000_0110111100_1, "mr. r0, r0"),
    // - register B
    (0b011111_00000_00000_11111_0110111100_0, "or r0, r0, r31"),
    // - register A
    (0b011111_00000_11111_00000_0110111100_0, "mr r31, r0"),
    // - register S
    (0b011111_11111_00000_00000_0110111100_0, "or r0, r31, r0"),
    // - use every feature, S = B
    (0b011111_00010_00001_00010_0110111100_1, "mr. r1, r2"),
    // - use every feature, S != B
    (0b011111_00010_00001_00011_0110111100_1, "or. r1, r2, r3"),
    //
    // === MTSPR ===
    //
    // - all variants with r0
    (0b011111_00000_00001_00000_0111010011_0, "mtxer r0"),
    (0b011111_00000_01000_00000_0111010011_0, "mtlr r0"),
    (0b011111_00000_01001_00000_0111010011_0, "mtctr r0"),
    // - reserved bit 31
    (0b011111_00000_00001_00000_0111010011_1, "FAIL"),
    // - register D
    (0b011111_11111_00001_00000_0111010011_0, "mtxer r31"),
    // - spr operand, illegal value
    (0b011111_00000_00000_00000_0111010011_0, "FAIL"),
    (0b011111_00000_00001_00001_0111010011_0, "FAIL"),
    //
    // === LWZ ===
    //
    // - all zeros
    (0b100000_00000_00000_0000000000000000, "lwz r0, (0)"),
    // - signed immediate
    (0b100000_00000_00000_1111111111111111, "lwz r0, -1(0)"),
    // - register A
    (0b100000_00000_11111_0000000000000000, "lwz r0, (r31)"),
    // - register D
    (0b100000_11111_00000_0000000000000000, "lwz r31, (0)"),
    // - all ones
    (0b100000_11111_11111_1111111111111111, "lwz r31, -1(r31)"),
    //
    // === STW ===
    //
    // - all zeros
    (0b100100_00000_00000_0000000000000000, "stw r0, (0)"),
    // - signed immediate
    (0b100100_00000_00000_1111111111111111, "stw r0, -1(0)"),
    // - register A
    (0b100100_00000_11111_0000000000000000, "stw r0, (r31)"),
    // - register S
    (0b100100_11111_00000_0000000000000000, "stw r31, (0)"),
    // - all ones
    (0b100100_11111_11111_1111111111111111, "stw r31, -1(r31)"),
    //
    // === STWU ===
    //
    // - all zeros
    (0b100101_00000_00001_0000000000000000, "stwu r0, (r1)"),
    // - signed immediate
    (0b100101_00000_00001_1111111111111111, "stwu r0, -1(r1)"),
    // - register A
    (0b100101_00000_11111_0000000000000000, "stwu r0, (r31)"),
    // - register A, illegal value
    (0b100101_00000_00000_0000000000000000, "FAIL"),
    // - register S
    (0b100101_11111_00001_0000000000000000, "stwu r31, (r1)"),
    // - all ones
    (0b100101_11111_11111_1111111111111111, "stwu r31, -1(r31)"),
];

#[test]
fn to_assembly() {
    for row in TABLE {
        let (decoded, expected_assembly) =
            match (EncodedInstruction(row.0).parse(0x08000000), row.1) {
                (Ok(decoded), "FAIL") => {
                    // Unexpected success.
                    panic!(
                        "unexpected success parsing 0b{:032b}. result: {:?}",
                        row.0, decoded,
                    );
                }
                (Ok(decoded), expected_assembly) => {
                    // Expected success.
                    (decoded, expected_assembly)
                }
                (Err(_), "FAIL") => {
                    // Expected failure.
                    continue;
                }
                (Err(e), expected_assembly) => {
                    // Unexpected failure
                    panic!(
                        "failed to parse 0b{:032b} (was expecting {:?}): {}",
                        row.0, expected_assembly, e
                    );
                }
            };

        let assembly = format!("{}", decoded);
        if assembly != expected_assembly {
            panic!(
                "assembly for 0b{:032b}, {:?}: want {:?}, but got {:?}",
                row.0, decoded, expected_assembly, assembly,
            );
        }
    }
}
