use crate::EncodedInstruction;

const TABLE: &[(u32, &str)] = &[
    //
    // === CMPLI (CMPLWI) ===
    // Opcode 10
    //
    // - all zeros
    (0b001010_000_0_0_00000_0000000000000000, "cmplwi r0, 0"),
    // - unsigned immediate
    (0b001010_000_0_0_00000_1111111111111111, "cmplwi r0, 0xffff"),
    // - register A
    (0b001010_000_0_0_11111_0000000000000000, "cmplwi r31, 0"),
    // - L flag
    (0b001010_000_0_1_00000_0000000000000000, "FAIL"),
    // - reserved bit 9
    (0b001010_000_1_0_00000_0000000000000000, "FAIL"),
    // - condition register field D
    (0b001010_111_0_0_00000_0000000000000000, "cmplwi cr7, r0, 0"),
    // - all ones
    (
        0b001010_111_0_0_11111_1111111111111111,
        "cmplwi cr7, r31, 0xffff",
    ),
    //
    // === CMPI (CMPWI) ===
    // Opcode 11
    //
    // - all zeros
    (0b001011_000_0_0_00000_0000000000000000, "cmpwi r0, 0"),
    // - signed immediate
    (0b001011_000_0_0_00000_1111111111111111, "cmpwi r0, -1"),
    // - register A
    (0b001011_000_0_0_11111_0000000000000000, "cmpwi r31, 0"),
    // - L flag
    (0b001011_000_0_1_00000_0000000000000000, "FAIL"),
    // - reserved bit 9
    (0b001011_000_1_0_00000_0000000000000000, "FAIL"),
    // - condition register field D
    (0b001011_111_0_0_00000_0000000000000000, "cmpwi cr7, r0, 0"),
    // - all ones
    (
        0b001011_111_0_0_11111_1111111111111111,
        "cmpwi cr7, r31, -1",
    ),
    //
    // === ADDI (LI) ===
    // Opcode 14
    //
    // - all zeros
    (0b001110_00000_00000_0000000000000000, "li r0, 0"),
    // - signed immediate
    (0b001110_00000_00000_1111111111111111, "li r0, -1"),
    // - register A
    (0b001110_00000_11111_0000000000000000, "addi r0, r31, 0"),
    // - register D
    (0b001110_11111_00000_0000000000000000, "li r31, 0"),
    // - all ones
    (0b001110_11111_11111_1111111111111111, "addi r31, r31, -1"),
    //
    // === ADDIS ===
    // Opcode 15
    //
    // - all zeros
    (0b001111_00000_00000_0000000000000000, "addis r0, 0, 0"),
    // - signed immediate
    (0b001111_00000_00000_1111111111111111, "addis r0, 0, -1"),
    // - register A
    (0b001111_00000_11111_0000000000000000, "addis r0, r31, 0"),
    // - register D
    (0b001111_11111_00000_0000000000000000, "addis r31, 0, 0"),
    // - all ones
    (0b001111_11111_11111_1111111111111111, "addis r31, r31, -1"),
    //
    // === BCx ===
    // Opcode 16
    //
    // - all zeros
    (0b010000_00000_00000_00000000000000_0_0, "bdnznl 0x08000000"),
    // - link flag
    (
        0b010000_00000_00000_00000000000000_0_1,
        "bdnznll 0x08000000",
    ),
    // - absolute flag
    (
        0b010000_00000_00000_00000000000000_1_0,
        "bdnznla 0x00000000",
    ),
    // - target address
    (0b010000_00000_00000_11111111111111_0_0, "bdnznl 0x07fffffc"),
    // - BI operand, condition
    (0b010000_00000_00011_00000000000000_0_0, "bdnzns 0x08000000"),
    // - BI operand, condition register field
    (
        0b010000_00000_11100_00000000000000_0_0,
        "bdnznl cr7, 0x08000000",
    ),
    // - BO operand
    (0b010000_11111_00000_00000000000000_0_0, "b 0x08000000"),
    // - all ones
    (0b010000_11111_11111_11111111111111_1_1, "bla 0xfffffffc"),
    // - all eight simple conditional branches
    (0b010000_01100_00000_00010000000000_0_0, "blt 0x08001000"),
    (0b010000_01100_00001_00010000000000_0_0, "bgt 0x08001000"),
    (0b010000_01100_00010_00010000000000_0_0, "beq 0x08001000"),
    (0b010000_01100_00011_00010000000000_0_0, "bso 0x08001000"),
    (0b010000_00100_00000_00010000000000_0_0, "bnl 0x08001000"),
    (0b010000_00100_00001_00010000000000_0_0, "bng 0x08001000"),
    (0b010000_00100_00010_00010000000000_0_0, "bne 0x08001000"),
    (0b010000_00100_00011_00010000000000_0_0, "bns 0x08001000"),
    // - use every feature
    (
        0b010000_01000_10110_00010010001101_1_1,
        "bdnzeqla cr5, 0x00001234",
    ),
    //
    // === Bx ===
    // Opcode 18
    //
    // - all zeros
    (0b010010_000000000000000000000000_0_0, "b 0x08000000"),
    // - link flag
    (0b010010_000000000000000000000000_0_1, "bl 0x08000000"),
    // - absolute flag
    (0b010010_000000000000000000000000_1_0, "ba 0x00000000"),
    // - target address
    (0b010010_111111111111111111111111_0_0, "b 0x07fffffc"),
    // - all ones
    (0b010010_111111111111111111111111_1_1, "bla 0xfffffffc"),
    //
    // === BCLRx ===
    // Opcode 19
    // Extended opcode 16
    //
    // - all zeros
    (0b010011_00000_00000_00000_0000010000_0, "bdnznllr"),
    // - link flag
    (0b010011_00000_00000_00000_0000010000_1, "bdnznllrl"),
    // reserved bits 16..=20
    (0b010011_00000_00000_00001_0000010000_1, "FAIL"),
    (0b010011_00000_00000_00010_0000010000_1, "FAIL"),
    (0b010011_00000_00000_00100_0000010000_1, "FAIL"),
    (0b010011_00000_00000_01000_0000010000_1, "FAIL"),
    (0b010011_00000_00000_10000_0000010000_1, "FAIL"),
    // - BI operand, condition
    (0b010011_00000_00011_00000_0000010000_0, "bdnznslr"),
    // - BI operand, condition register field
    (0b010011_00000_11100_00000_0000010000_0, "bdnznllr cr7"),
    // - BO operand
    (0b010011_11111_00000_00000_0000010000_0, "blr"),
    // - all ones
    (0b010011_11111_11111_00000_0000010000_1, "blrl"),
    // - all eight simple conditional branches
    (0b010011_01100_00000_00000_0000010000_0, "bltlr"),
    (0b010011_01100_00001_00000_0000010000_0, "bgtlr"),
    (0b010011_01100_00010_00000_0000010000_0, "beqlr"),
    (0b010011_01100_00011_00000_0000010000_0, "bsolr"),
    (0b010011_00100_00000_00000_0000010000_0, "bnllr"),
    (0b010011_00100_00001_00000_0000010000_0, "bnglr"),
    (0b010011_00100_00010_00000_0000010000_0, "bnelr"),
    (0b010011_00100_00011_00000_0000010000_0, "bnslr"),
    // - use every feature
    (0b010011_01000_10110_00000_0000010000_1, "bdnzeqlrl cr5"),
    //
    // === CRXOR ===
    // Opcode 19
    // Extended opcode 193
    //
    // - all zeros
    (0b010011_00000_00000_00000_0011000001_0, "crxor lt, lt, lt"),
    // - reserved bit 31
    (0b010011_00000_00000_00000_0011000001_1, "FAIL"),
    // - crbB operand
    (
        0b010011_00000_00000_11111_0011000001_0,
        "crxor lt, lt, cr7*4+so",
    ),
    // - crbA operand
    (
        0b010011_00000_11111_00000_0011000001_0,
        "crxor lt, cr7*4+so, lt",
    ),
    // - crbD operand
    (
        0b010011_11111_00000_00000_0011000001_0,
        "crxor cr7*4+so, lt, lt",
    ),
    // - all ones
    (
        0b010011_11111_11111_11111_0011000001_0,
        "crxor cr7*4+so, cr7*4+so, cr7*4+so",
    ),
    //
    // === RLWINM ===
    // Opcode 21
    //
    // - all zeros
    (
        0b010101_00000_00000_00000_00000_00000_0,
        "rlwinm r0, r0, 0, 0, 0",
    ),
    // - record bit
    (
        0b010101_00000_00000_00000_00000_00000_1,
        "rlwinm. r0, r0, 0, 0, 0",
    ),
    // - ME operand
    (
        0b010101_00000_00000_00000_00000_11111_0,
        "rlwinm r0, r0, 0, 0, 31",
    ),
    // - MB operand
    (
        0b010101_00000_00000_00000_11111_00000_0,
        "rlwinm r0, r0, 0, 31, 0",
    ),
    // - SH operand
    (
        0b010101_00000_00000_11111_00000_00000_0,
        "rlwinm r0, r0, 31, 0, 0",
    ),
    // - A register
    (
        0b010101_00000_11111_00000_00000_00000_0,
        "rlwinm r31, r0, 0, 0, 0",
    ),
    // - S register
    (
        0b010101_11111_00000_00000_00000_00000_0,
        "rlwinm r0, r31, 0, 0, 0",
    ),
    // - all ones
    (
        0b010101_11111_11111_11111_11111_11111_1,
        "rlwinm. r31, r31, 31, 31, 31",
    ),
    //
    // === CMPL (CMPLW) ===
    // Opcode 31
    // Extended opcode 32
    //
    // - all zeros
    (0b011111_000_0_0_00000_00000_0000100000_0, "cmplw r0, r0"),
    // - reserved bit 31
    (0b011111_000_0_0_00000_00000_0000100000_1, "FAIL"),
    // - register B
    (0b011111_000_0_0_00000_11111_0000100000_0, "cmplw r0, r31"),
    // - register A
    (0b011111_000_0_0_11111_00000_0000100000_0, "cmplw r31, r0"),
    // - L flag
    (0b011111_000_0_1_00000_00000_0000100000_0, "FAIL"),
    // - reserved bit 9
    (0b011111_000_1_0_00000_00000_0000100000_0, "FAIL"),
    // - condition register field D
    (
        0b011111_111_0_0_00000_00000_0000100000_0,
        "cmplw cr7, r0, r0",
    ),
    // - all ones
    (
        0b011111_111_0_0_11111_11111_0000100000_0,
        "cmplw cr7, r31, r31",
    ),
    //
    // === ADDZE ===
    // Opcode 31
    // Extended opcode 202
    //
    // - all zeros
    (0b011111_00000_00000_00000_0_011001010_0, "addze r0, r0"),
    // - record bit
    (0b011111_00000_00000_00000_0_011001010_1, "addze. r0, r0"),
    // - OE operand
    (0b011111_00000_00000_00000_1_011001010_0, "addzeo r0, r0"),
    // - reserved bits 16..20
    (0b011111_00000_00000_00001_0_011001010_0, "FAIL"),
    (0b011111_00000_00000_00010_0_011001010_0, "FAIL"),
    (0b011111_00000_00000_00100_0_011001010_0, "FAIL"),
    (0b011111_00000_00000_01000_0_011001010_0, "FAIL"),
    (0b011111_00000_00000_10000_0_011001010_0, "FAIL"),
    // - register A
    (0b011111_00000_11111_00000_0_011001010_0, "addze r0, r31"),
    // - register D
    (0b011111_11111_00000_00000_0_011001010_0, "addze r31, r0"),
    // - all ones
    (0b011111_11111_11111_00000_1_011001010_1, "addzeo. r31, r31"),
    //
    // === MFSPR ===
    // Opcode 31
    // Extended opcode 339
    //
    // - all variants with r0
    (0b011111_00000_00001_00000_0101010011_0, "mfxer r0"),
    (0b011111_00000_01000_00000_0101010011_0, "mflr r0"),
    (0b011111_00000_01001_00000_0101010011_0, "mfctr r0"),
    (0b011111_00000_10001_11100_0101010011_0, "mfgqr1 r0"),
    (0b011111_00000_10010_11100_0101010011_0, "mfgqr2 r0"),
    (0b011111_00000_10011_11100_0101010011_0, "mfgqr3 r0"),
    (0b011111_00000_10100_11100_0101010011_0, "mfgqr4 r0"),
    (0b011111_00000_10101_11100_0101010011_0, "mfgqr5 r0"),
    (0b011111_00000_10110_11100_0101010011_0, "mfgqr6 r0"),
    (0b011111_00000_10111_11100_0101010011_0, "mfgqr7 r0"),
    // - reserved bit 31
    (0b011111_00000_00001_00000_0101010011_1, "FAIL"),
    // - register D
    (0b011111_11111_00001_00000_0101010011_0, "mfxer r31"),
    // - spr operand, illegal value
    (0b011111_00000_00000_00000_0101010011_0, "FAIL"),
    (0b011111_00000_00001_00001_0101010011_0, "FAIL"),
    //
    // === OR (MR) ===
    // Opcode 31
    // Extended opcode 444
    //
    // - all zeros
    (0b011111_00000_00000_00000_0110111100_0, "mr r0, r0"),
    // - record bit
    (0b011111_00000_00000_00000_0110111100_1, "mr. r0, r0"),
    // - register B
    (0b011111_00000_00000_11111_0110111100_0, "or r0, r0, r31"),
    // - register A
    (0b011111_00000_11111_00000_0110111100_0, "mr r31, r0"),
    // - register S
    (0b011111_11111_00000_00000_0110111100_0, "or r0, r31, r0"),
    // - use every feature, S = B
    (0b011111_00010_00001_00010_0110111100_1, "mr. r1, r2"),
    // - use every feature, S != B
    (0b011111_00010_00001_00011_0110111100_1, "or. r1, r2, r3"),
    //
    // === MTSPR ===
    // Opcode 31
    // Extended opcode 467
    //
    // - all variants with r0
    (0b011111_00000_00001_00000_0111010011_0, "mtxer r0"),
    (0b011111_00000_01000_00000_0111010011_0, "mtlr r0"),
    (0b011111_00000_01001_00000_0111010011_0, "mtctr r0"),
    // - reserved bit 31
    (0b011111_00000_00001_00000_0111010011_1, "FAIL"),
    // - register D
    (0b011111_11111_00001_00000_0111010011_0, "mtxer r31"),
    // - spr operand, illegal value
    (0b011111_00000_00000_00000_0111010011_0, "FAIL"),
    (0b011111_00000_00001_00001_0111010011_0, "FAIL"),
    //
    // === SRAWI ===
    // Opcode 31
    // Extended opcode 824
    //
    // - all zeros
    (0b011111_00000_00000_00000_1100111000_0, "srawi r0, r0, 0"),
    // - record bit
    (0b011111_00000_00000_00000_1100111000_1, "srawi. r0, r0, 0"),
    // - shift amount
    (0b011111_00000_00000_11111_1100111000_0, "srawi r0, r0, 31"),
    // - register A
    (0b011111_00000_11111_00000_1100111000_0, "srawi r31, r0, 0"),
    // - register S
    (0b011111_11111_00000_00000_1100111000_0, "srawi r0, r31, 0"),
    // - all ones
    (
        0b011111_11111_11111_11111_1100111000_1,
        "srawi. r31, r31, 31",
    ),
    //
    // === LWZ ===
    // Opcode 32
    //
    // - all zeros
    (0b100000_00000_00000_0000000000000000, "lwz r0, (0)"),
    // - signed immediate
    (0b100000_00000_00000_1111111111111111, "lwz r0, -1(0)"),
    // - register A
    (0b100000_00000_11111_0000000000000000, "lwz r0, (r31)"),
    // - register D
    (0b100000_11111_00000_0000000000000000, "lwz r31, (0)"),
    // - all ones
    (0b100000_11111_11111_1111111111111111, "lwz r31, -1(r31)"),
    //
    // === LBZ ===
    // Opcode 34
    //
    // - all zeros
    (0b100010_00000_00000_0000000000000000, "lbz r0, (0)"),
    // - signed immediate
    (0b100010_00000_00000_1111111111111111, "lbz r0, -1(0)"),
    // - register A
    (0b100010_00000_11111_0000000000000000, "lbz r0, (r31)"),
    // - register D
    (0b100010_11111_00000_0000000000000000, "lbz r31, (0)"),
    // - all ones
    (0b100010_11111_11111_1111111111111111, "lbz r31, -1(r31)"),
    //
    // === STW ===
    // Opcode 36
    //
    // - all zeros
    (0b100100_00000_00000_0000000000000000, "stw r0, (0)"),
    // - signed immediate
    (0b100100_00000_00000_1111111111111111, "stw r0, -1(0)"),
    // - register A
    (0b100100_00000_11111_0000000000000000, "stw r0, (r31)"),
    // - register S
    (0b100100_11111_00000_0000000000000000, "stw r31, (0)"),
    // - all ones
    (0b100100_11111_11111_1111111111111111, "stw r31, -1(r31)"),
    //
    // === STWU ===
    // Opcode 37
    //
    // - all zeros
    (0b100101_00000_00001_0000000000000000, "stwu r0, (r1)"),
    // - signed immediate
    (0b100101_00000_00001_1111111111111111, "stwu r0, -1(r1)"),
    // - register A
    (0b100101_00000_11111_0000000000000000, "stwu r0, (r31)"),
    // - register A, illegal value
    (0b100101_00000_00000_0000000000000000, "FAIL"),
    // - register S
    (0b100101_11111_00001_0000000000000000, "stwu r31, (r1)"),
    // - all ones
    (0b100101_11111_11111_1111111111111111, "stwu r31, -1(r31)"),
    //
    // === LHA ===
    // Opcode 42
    //
    // - all zeros
    (0b101010_00000_00000_0000000000000000, "lha r0, (0)"),
    // - signed immediate
    (0b101010_00000_00000_1111111111111111, "lha r0, -1(0)"),
    // - register A
    (0b101010_00000_11111_0000000000000000, "lha r0, (r31)"),
    // - register D
    (0b101010_11111_00000_0000000000000000, "lha r31, (0)"),
    // - all ones
    (0b101010_11111_11111_1111111111111111, "lha r31, -1(r31)"),
    //
    // === STMW ===
    // Opcode 47
    //
    // - all zeros
    (0b101111_00000_00000_0000000000000000, "stmw r0, (0)"),
    // - signed immediate
    (0b101111_00000_00000_1111111111111111, "stmw r0, -1(0)"),
    // - register A
    (0b101111_00000_11111_0000000000000000, "stmw r0, (r31)"),
    // - register S
    (0b101111_11111_00000_0000000000000000, "stmw r31, (0)"),
    // - all ones
    (0b101111_11111_11111_1111111111111111, "stmw r31, -1(r31)"),
];

#[test]
fn to_assembly() {
    let mut any_errors = false;

    for row in TABLE {
        let (decoded, expected_assembly) =
            match (EncodedInstruction(row.0).parse(0x08000000), row.1) {
                (Ok(decoded), "FAIL") => {
                    // Unexpected success.
                    any_errors = true;
                    eprintln!(
                        "unexpected success parsing 0b{:032b}. result: {:?}",
                        row.0, decoded,
                    );
                    continue;
                }
                (Ok(decoded), expected_assembly) => {
                    // Expected success.
                    (decoded, expected_assembly)
                }
                (Err(_), "FAIL") => {
                    // Expected failure.
                    continue;
                }
                (Err(e), expected_assembly) => {
                    // Unexpected failure
                    any_errors = true;
                    eprintln!(
                        "failed to parse 0b{:032b} (was expecting {:?}): {}",
                        row.0, expected_assembly, e
                    );
                    continue;
                }
            };

        let assembly = format!("{}", decoded);
        if assembly != expected_assembly {
            any_errors = true;
            eprintln!(
                "assembly for 0b{:032b}, {:?}: want {:?}, but got {:?}",
                row.0, decoded, expected_assembly, assembly,
            );
            continue;
        }
    }

    if any_errors {
        panic!("one or more table test cases failed");
    }
}
